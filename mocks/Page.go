// Code generated by mockery v2.22.1. DO NOT EDIT.

package mocks

import (
	playwright "github.com/playwright-community/playwright-go"
	mock "github.com/stretchr/testify/mock"
)

// Page is an autogenerated mock type for the Page type
type Page struct {
	mock.Mock
}

// AddInitScript provides a mock function with given fields: script
func (_m *Page) AddInitScript(script playwright.PageAddInitScriptOptions) error {
	ret := _m.Called(script)

	var r0 error
	if rf, ok := ret.Get(0).(func(playwright.PageAddInitScriptOptions) error); ok {
		r0 = rf(script)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddScriptTag provides a mock function with given fields: options
func (_m *Page) AddScriptTag(options playwright.PageAddScriptTagOptions) (playwright.ElementHandle, error) {
	ret := _m.Called(options)

	var r0 playwright.ElementHandle
	var r1 error
	if rf, ok := ret.Get(0).(func(playwright.PageAddScriptTagOptions) (playwright.ElementHandle, error)); ok {
		return rf(options)
	}
	if rf, ok := ret.Get(0).(func(playwright.PageAddScriptTagOptions) playwright.ElementHandle); ok {
		r0 = rf(options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.ElementHandle)
		}
	}

	if rf, ok := ret.Get(1).(func(playwright.PageAddScriptTagOptions) error); ok {
		r1 = rf(options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddStyleTag provides a mock function with given fields: options
func (_m *Page) AddStyleTag(options playwright.PageAddStyleTagOptions) (playwright.ElementHandle, error) {
	ret := _m.Called(options)

	var r0 playwright.ElementHandle
	var r1 error
	if rf, ok := ret.Get(0).(func(playwright.PageAddStyleTagOptions) (playwright.ElementHandle, error)); ok {
		return rf(options)
	}
	if rf, ok := ret.Get(0).(func(playwright.PageAddStyleTagOptions) playwright.ElementHandle); ok {
		r0 = rf(options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.ElementHandle)
		}
	}

	if rf, ok := ret.Get(1).(func(playwright.PageAddStyleTagOptions) error); ok {
		r1 = rf(options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BringToFront provides a mock function with given fields:
func (_m *Page) BringToFront() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Check provides a mock function with given fields: selector, options
func (_m *Page) Check(selector string, options ...playwright.FrameCheckOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameCheckOptions) error); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Click provides a mock function with given fields: selector, options
func (_m *Page) Click(selector string, options ...playwright.PageClickOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageClickOptions) error); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Close provides a mock function with given fields: options
func (_m *Page) Close(options ...playwright.PageCloseOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(...playwright.PageCloseOptions) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Content provides a mock function with given fields:
func (_m *Page) Content() (string, error) {
	ret := _m.Called()

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Context provides a mock function with given fields:
func (_m *Page) Context() playwright.BrowserContext {
	ret := _m.Called()

	var r0 playwright.BrowserContext
	if rf, ok := ret.Get(0).(func() playwright.BrowserContext); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.BrowserContext)
		}
	}

	return r0
}

// Dblclick provides a mock function with given fields: expression, options
func (_m *Page) Dblclick(expression string, options ...playwright.FrameDblclickOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, expression)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameDblclickOptions) error); ok {
		r0 = rf(expression, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DispatchEvent provides a mock function with given fields: selector, typ, options
func (_m *Page) DispatchEvent(selector string, typ string, options ...playwright.PageDispatchEventOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector, typ)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...playwright.PageDispatchEventOptions) error); ok {
		r0 = rf(selector, typ, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DragAndDrop provides a mock function with given fields: source, target, options
func (_m *Page) DragAndDrop(source string, target string, options ...playwright.FrameDragAndDropOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, source, target)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...playwright.FrameDragAndDropOptions) error); ok {
		r0 = rf(source, target, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Emit provides a mock function with given fields: name, payload
func (_m *Page) Emit(name string, payload ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, payload...)
	_m.Called(_ca...)
}

// EmulateMedia provides a mock function with given fields: options
func (_m *Page) EmulateMedia(options ...playwright.PageEmulateMediaOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(...playwright.PageEmulateMediaOptions) error); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EvalOnSelector provides a mock function with given fields: selector, expression, options
func (_m *Page) EvalOnSelector(selector string, expression string, options ...interface{}) (interface{}, error) {
	var _ca []interface{}
	_ca = append(_ca, selector, expression)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...interface{}) (interface{}, error)); ok {
		return rf(selector, expression, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...interface{}) interface{}); ok {
		r0 = rf(selector, expression, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...interface{}) error); ok {
		r1 = rf(selector, expression, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvalOnSelectorAll provides a mock function with given fields: selector, expression, options
func (_m *Page) EvalOnSelectorAll(selector string, expression string, options ...interface{}) (interface{}, error) {
	var _ca []interface{}
	_ca = append(_ca, selector, expression)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...interface{}) (interface{}, error)); ok {
		return rf(selector, expression, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...interface{}) interface{}); ok {
		r0 = rf(selector, expression, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...interface{}) error); ok {
		r1 = rf(selector, expression, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Evaluate provides a mock function with given fields: expression, options
func (_m *Page) Evaluate(expression string, options ...interface{}) (interface{}, error) {
	var _ca []interface{}
	_ca = append(_ca, expression)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (interface{}, error)); ok {
		return rf(expression, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) interface{}); ok {
		r0 = rf(expression, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(expression, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvaluateHandle provides a mock function with given fields: expression, options
func (_m *Page) EvaluateHandle(expression string, options ...interface{}) (playwright.JSHandle, error) {
	var _ca []interface{}
	_ca = append(_ca, expression)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	var r0 playwright.JSHandle
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (playwright.JSHandle, error)); ok {
		return rf(expression, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) playwright.JSHandle); ok {
		r0 = rf(expression, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.JSHandle)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(expression, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectConsoleMessage provides a mock function with given fields: cb
func (_m *Page) ExpectConsoleMessage(cb func() error) (playwright.ConsoleMessage, error) {
	ret := _m.Called(cb)

	var r0 playwright.ConsoleMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(func() error) (playwright.ConsoleMessage, error)); ok {
		return rf(cb)
	}
	if rf, ok := ret.Get(0).(func(func() error) playwright.ConsoleMessage); ok {
		r0 = rf(cb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.ConsoleMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(func() error) error); ok {
		r1 = rf(cb)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectDownload provides a mock function with given fields: cb
func (_m *Page) ExpectDownload(cb func() error) (playwright.Download, error) {
	ret := _m.Called(cb)

	var r0 playwright.Download
	var r1 error
	if rf, ok := ret.Get(0).(func(func() error) (playwright.Download, error)); ok {
		return rf(cb)
	}
	if rf, ok := ret.Get(0).(func(func() error) playwright.Download); ok {
		r0 = rf(cb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Download)
		}
	}

	if rf, ok := ret.Get(1).(func(func() error) error); ok {
		r1 = rf(cb)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectEvent provides a mock function with given fields: event, cb, predicates
func (_m *Page) ExpectEvent(event string, cb func() error, predicates ...interface{}) (interface{}, error) {
	var _ca []interface{}
	_ca = append(_ca, event, cb)
	_ca = append(_ca, predicates...)
	ret := _m.Called(_ca...)

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, func() error, ...interface{}) (interface{}, error)); ok {
		return rf(event, cb, predicates...)
	}
	if rf, ok := ret.Get(0).(func(string, func() error, ...interface{}) interface{}); ok {
		r0 = rf(event, cb, predicates...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, func() error, ...interface{}) error); ok {
		r1 = rf(event, cb, predicates...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectFileChooser provides a mock function with given fields: cb
func (_m *Page) ExpectFileChooser(cb func() error) (playwright.FileChooser, error) {
	ret := _m.Called(cb)

	var r0 playwright.FileChooser
	var r1 error
	if rf, ok := ret.Get(0).(func(func() error) (playwright.FileChooser, error)); ok {
		return rf(cb)
	}
	if rf, ok := ret.Get(0).(func(func() error) playwright.FileChooser); ok {
		r0 = rf(cb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.FileChooser)
		}
	}

	if rf, ok := ret.Get(1).(func(func() error) error); ok {
		r1 = rf(cb)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectLoadState provides a mock function with given fields: state, cb
func (_m *Page) ExpectLoadState(state string, cb func() error) error {
	ret := _m.Called(state, cb)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, func() error) error); ok {
		r0 = rf(state, cb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExpectNavigation provides a mock function with given fields: cb, options
func (_m *Page) ExpectNavigation(cb func() error, options ...playwright.PageWaitForNavigationOptions) (playwright.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, cb)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 playwright.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(func() error, ...playwright.PageWaitForNavigationOptions) (playwright.Response, error)); ok {
		return rf(cb, options...)
	}
	if rf, ok := ret.Get(0).(func(func() error, ...playwright.PageWaitForNavigationOptions) playwright.Response); ok {
		r0 = rf(cb, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(func() error, ...playwright.PageWaitForNavigationOptions) error); ok {
		r1 = rf(cb, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectPopup provides a mock function with given fields: cb
func (_m *Page) ExpectPopup(cb func() error) (playwright.Page, error) {
	ret := _m.Called(cb)

	var r0 playwright.Page
	var r1 error
	if rf, ok := ret.Get(0).(func(func() error) (playwright.Page, error)); ok {
		return rf(cb)
	}
	if rf, ok := ret.Get(0).(func(func() error) playwright.Page); ok {
		r0 = rf(cb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Page)
		}
	}

	if rf, ok := ret.Get(1).(func(func() error) error); ok {
		r1 = rf(cb)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectRequest provides a mock function with given fields: url, cb, options
func (_m *Page) ExpectRequest(url interface{}, cb func() error, options ...interface{}) (playwright.Request, error) {
	var _ca []interface{}
	_ca = append(_ca, url, cb)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	var r0 playwright.Request
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, func() error, ...interface{}) (playwright.Request, error)); ok {
		return rf(url, cb, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, func() error, ...interface{}) playwright.Request); ok {
		r0 = rf(url, cb, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, func() error, ...interface{}) error); ok {
		r1 = rf(url, cb, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectResponse provides a mock function with given fields: url, cb, options
func (_m *Page) ExpectResponse(url interface{}, cb func() error, options ...interface{}) (playwright.Response, error) {
	var _ca []interface{}
	_ca = append(_ca, url, cb)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	var r0 playwright.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, func() error, ...interface{}) (playwright.Response, error)); ok {
		return rf(url, cb, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, func() error, ...interface{}) playwright.Response); ok {
		r0 = rf(url, cb, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, func() error, ...interface{}) error); ok {
		r1 = rf(url, cb, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectWorker provides a mock function with given fields: cb
func (_m *Page) ExpectWorker(cb func() error) (playwright.Worker, error) {
	ret := _m.Called(cb)

	var r0 playwright.Worker
	var r1 error
	if rf, ok := ret.Get(0).(func(func() error) (playwright.Worker, error)); ok {
		return rf(cb)
	}
	if rf, ok := ret.Get(0).(func(func() error) playwright.Worker); ok {
		r0 = rf(cb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Worker)
		}
	}

	if rf, ok := ret.Get(1).(func(func() error) error); ok {
		r1 = rf(cb)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpectedDialog provides a mock function with given fields: cb
func (_m *Page) ExpectedDialog(cb func() error) (playwright.Dialog, error) {
	ret := _m.Called(cb)

	var r0 playwright.Dialog
	var r1 error
	if rf, ok := ret.Get(0).(func(func() error) (playwright.Dialog, error)); ok {
		return rf(cb)
	}
	if rf, ok := ret.Get(0).(func(func() error) playwright.Dialog); ok {
		r0 = rf(cb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Dialog)
		}
	}

	if rf, ok := ret.Get(1).(func(func() error) error); ok {
		r1 = rf(cb)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExposeBinding provides a mock function with given fields: name, binding, handle
func (_m *Page) ExposeBinding(name string, binding playwright.BindingCallFunction, handle ...bool) error {
	_va := make([]interface{}, len(handle))
	for _i := range handle {
		_va[_i] = handle[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, binding)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, playwright.BindingCallFunction, ...bool) error); ok {
		r0 = rf(name, binding, handle...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExposeFunction provides a mock function with given fields: name, binding
func (_m *Page) ExposeFunction(name string, binding func(...interface{}) interface{}) error {
	ret := _m.Called(name, binding)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, func(...interface{}) interface{}) error); ok {
		r0 = rf(name, binding)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Fill provides a mock function with given fields: selector, text, options
func (_m *Page) Fill(selector string, text string, options ...playwright.FrameFillOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector, text)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...playwright.FrameFillOptions) error); ok {
		r0 = rf(selector, text, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Focus provides a mock function with given fields: expression, options
func (_m *Page) Focus(expression string, options ...playwright.FrameFocusOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, expression)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameFocusOptions) error); ok {
		r0 = rf(expression, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Frame provides a mock function with given fields: options
func (_m *Page) Frame(options playwright.PageFrameOptions) playwright.Frame {
	ret := _m.Called(options)

	var r0 playwright.Frame
	if rf, ok := ret.Get(0).(func(playwright.PageFrameOptions) playwright.Frame); ok {
		r0 = rf(options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Frame)
		}
	}

	return r0
}

// Frames provides a mock function with given fields:
func (_m *Page) Frames() []playwright.Frame {
	ret := _m.Called()

	var r0 []playwright.Frame
	if rf, ok := ret.Get(0).(func() []playwright.Frame); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]playwright.Frame)
		}
	}

	return r0
}

// GetAttribute provides a mock function with given fields: selector, name, options
func (_m *Page) GetAttribute(selector string, name string, options ...playwright.PageGetAttributeOptions) (string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...playwright.PageGetAttributeOptions) (string, error)); ok {
		return rf(selector, name, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...playwright.PageGetAttributeOptions) string); ok {
		r0 = rf(selector, name, options...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...playwright.PageGetAttributeOptions) error); ok {
		r1 = rf(selector, name, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GoBack provides a mock function with given fields: options
func (_m *Page) GoBack(options ...playwright.PageGoBackOptions) (playwright.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 playwright.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(...playwright.PageGoBackOptions) (playwright.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...playwright.PageGoBackOptions) playwright.Response); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(...playwright.PageGoBackOptions) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GoForward provides a mock function with given fields: options
func (_m *Page) GoForward(options ...playwright.PageGoForwardOptions) (playwright.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 playwright.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(...playwright.PageGoForwardOptions) (playwright.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...playwright.PageGoForwardOptions) playwright.Response); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(...playwright.PageGoForwardOptions) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Goto provides a mock function with given fields: url, options
func (_m *Page) Goto(url string, options ...playwright.PageGotoOptions) (playwright.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, url)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 playwright.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageGotoOptions) (playwright.Response, error)); ok {
		return rf(url, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageGotoOptions) playwright.Response); ok {
		r0 = rf(url, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.PageGotoOptions) error); ok {
		r1 = rf(url, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Hover provides a mock function with given fields: selector, options
func (_m *Page) Hover(selector string, options ...playwright.PageHoverOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageHoverOptions) error); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InnerHTML provides a mock function with given fields: selector, options
func (_m *Page) InnerHTML(selector string, options ...playwright.PageInnerHTMLOptions) (string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageInnerHTMLOptions) (string, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageInnerHTMLOptions) string); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.PageInnerHTMLOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InnerText provides a mock function with given fields: selector, options
func (_m *Page) InnerText(selector string, options ...playwright.PageInnerTextOptions) (string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageInnerTextOptions) (string, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageInnerTextOptions) string); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.PageInnerTextOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InputValue provides a mock function with given fields: selector, options
func (_m *Page) InputValue(selector string, options ...playwright.FrameInputValueOptions) (string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameInputValueOptions) (string, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameInputValueOptions) string); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.FrameInputValueOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsChecked provides a mock function with given fields: selector, options
func (_m *Page) IsChecked(selector string, options ...playwright.FrameIsCheckedOptions) (bool, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsCheckedOptions) (bool, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsCheckedOptions) bool); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.FrameIsCheckedOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsClosed provides a mock function with given fields:
func (_m *Page) IsClosed() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsDisabled provides a mock function with given fields: selector, options
func (_m *Page) IsDisabled(selector string, options ...playwright.FrameIsDisabledOptions) (bool, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsDisabledOptions) (bool, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsDisabledOptions) bool); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.FrameIsDisabledOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsEditable provides a mock function with given fields: selector, options
func (_m *Page) IsEditable(selector string, options ...playwright.FrameIsEditableOptions) (bool, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsEditableOptions) (bool, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsEditableOptions) bool); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.FrameIsEditableOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsEnabled provides a mock function with given fields: selector, options
func (_m *Page) IsEnabled(selector string, options ...playwright.FrameIsEnabledOptions) (bool, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsEnabledOptions) (bool, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsEnabledOptions) bool); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.FrameIsEnabledOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsHidden provides a mock function with given fields: selector, options
func (_m *Page) IsHidden(selector string, options ...playwright.FrameIsHiddenOptions) (bool, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsHiddenOptions) (bool, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsHiddenOptions) bool); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.FrameIsHiddenOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsVisible provides a mock function with given fields: selector, options
func (_m *Page) IsVisible(selector string, options ...playwright.FrameIsVisibleOptions) (bool, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsVisibleOptions) (bool, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameIsVisibleOptions) bool); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.FrameIsVisibleOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Keyboard provides a mock function with given fields:
func (_m *Page) Keyboard() playwright.Keyboard {
	ret := _m.Called()

	var r0 playwright.Keyboard
	if rf, ok := ret.Get(0).(func() playwright.Keyboard); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Keyboard)
		}
	}

	return r0
}

// ListenerCount provides a mock function with given fields: name
func (_m *Page) ListenerCount(name string) int {
	ret := _m.Called(name)

	var r0 int
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Locator provides a mock function with given fields: selector, options
func (_m *Page) Locator(selector string, options ...playwright.PageLocatorOptions) (playwright.Locator, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 playwright.Locator
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageLocatorOptions) (playwright.Locator, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageLocatorOptions) playwright.Locator); ok {
		r0 = rf(selector, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Locator)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.PageLocatorOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MainFrame provides a mock function with given fields:
func (_m *Page) MainFrame() playwright.Frame {
	ret := _m.Called()

	var r0 playwright.Frame
	if rf, ok := ret.Get(0).(func() playwright.Frame); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Frame)
		}
	}

	return r0
}

// Mouse provides a mock function with given fields:
func (_m *Page) Mouse() playwright.Mouse {
	ret := _m.Called()

	var r0 playwright.Mouse
	if rf, ok := ret.Get(0).(func() playwright.Mouse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Mouse)
		}
	}

	return r0
}

// On provides a mock function with given fields: name, handler
func (_m *Page) On(name string, handler interface{}) {
	_m.Called(name, handler)
}

// Once provides a mock function with given fields: name, handler
func (_m *Page) Once(name string, handler interface{}) {
	_m.Called(name, handler)
}

// Opener provides a mock function with given fields:
func (_m *Page) Opener() (playwright.Page, error) {
	ret := _m.Called()

	var r0 playwright.Page
	var r1 error
	if rf, ok := ret.Get(0).(func() (playwright.Page, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() playwright.Page); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Page)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PDF provides a mock function with given fields: options
func (_m *Page) PDF(options ...playwright.PagePdfOptions) ([]byte, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(...playwright.PagePdfOptions) ([]byte, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...playwright.PagePdfOptions) []byte); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(...playwright.PagePdfOptions) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Pause provides a mock function with given fields:
func (_m *Page) Pause() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Press provides a mock function with given fields: selector, key, options
func (_m *Page) Press(selector string, key string, options ...playwright.PagePressOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...playwright.PagePressOptions) error); ok {
		r0 = rf(selector, key, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// QuerySelector provides a mock function with given fields: selector
func (_m *Page) QuerySelector(selector string) (playwright.ElementHandle, error) {
	ret := _m.Called(selector)

	var r0 playwright.ElementHandle
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (playwright.ElementHandle, error)); ok {
		return rf(selector)
	}
	if rf, ok := ret.Get(0).(func(string) playwright.ElementHandle); ok {
		r0 = rf(selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.ElementHandle)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QuerySelectorAll provides a mock function with given fields: selector
func (_m *Page) QuerySelectorAll(selector string) ([]playwright.ElementHandle, error) {
	ret := _m.Called(selector)

	var r0 []playwright.ElementHandle
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]playwright.ElementHandle, error)); ok {
		return rf(selector)
	}
	if rf, ok := ret.Get(0).(func(string) []playwright.ElementHandle); ok {
		r0 = rf(selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]playwright.ElementHandle)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Reload provides a mock function with given fields: options
func (_m *Page) Reload(options ...playwright.PageReloadOptions) (playwright.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 playwright.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(...playwright.PageReloadOptions) (playwright.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...playwright.PageReloadOptions) playwright.Response); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(...playwright.PageReloadOptions) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveListener provides a mock function with given fields: name, handler
func (_m *Page) RemoveListener(name string, handler interface{}) {
	_m.Called(name, handler)
}

// Route provides a mock function with given fields: url, handler
func (_m *Page) Route(url interface{}, handler func(playwright.Route, playwright.Request)) error {
	ret := _m.Called(url, handler)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, func(playwright.Route, playwright.Request)) error); ok {
		r0 = rf(url, handler)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Screenshot provides a mock function with given fields: options
func (_m *Page) Screenshot(options ...playwright.PageScreenshotOptions) ([]byte, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(...playwright.PageScreenshotOptions) ([]byte, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...playwright.PageScreenshotOptions) []byte); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(...playwright.PageScreenshotOptions) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelectOption provides a mock function with given fields: selector, values, options
func (_m *Page) SelectOption(selector string, values playwright.SelectOptionValues, options ...playwright.FrameSelectOptionOptions) ([]string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector, values)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, playwright.SelectOptionValues, ...playwright.FrameSelectOptionOptions) ([]string, error)); ok {
		return rf(selector, values, options...)
	}
	if rf, ok := ret.Get(0).(func(string, playwright.SelectOptionValues, ...playwright.FrameSelectOptionOptions) []string); ok {
		r0 = rf(selector, values, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, playwright.SelectOptionValues, ...playwright.FrameSelectOptionOptions) error); ok {
		r1 = rf(selector, values, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetChecked provides a mock function with given fields: selector, checked, options
func (_m *Page) SetChecked(selector string, checked bool, options ...playwright.FrameSetCheckedOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector, checked)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, bool, ...playwright.FrameSetCheckedOptions) error); ok {
		r0 = rf(selector, checked, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetContent provides a mock function with given fields: content, options
func (_m *Page) SetContent(content string, options ...playwright.PageSetContentOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, content)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageSetContentOptions) error); ok {
		r0 = rf(content, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetDefaultNavigationTimeout provides a mock function with given fields: timeout
func (_m *Page) SetDefaultNavigationTimeout(timeout float64) {
	_m.Called(timeout)
}

// SetDefaultTimeout provides a mock function with given fields: timeout
func (_m *Page) SetDefaultTimeout(timeout float64) {
	_m.Called(timeout)
}

// SetExtraHTTPHeaders provides a mock function with given fields: headers
func (_m *Page) SetExtraHTTPHeaders(headers map[string]string) error {
	ret := _m.Called(headers)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]string) error); ok {
		r0 = rf(headers)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetInputFiles provides a mock function with given fields: selector, files, options
func (_m *Page) SetInputFiles(selector string, files []playwright.InputFile, options ...playwright.FrameSetInputFilesOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector, files)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []playwright.InputFile, ...playwright.FrameSetInputFilesOptions) error); ok {
		r0 = rf(selector, files, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetViewportSize provides a mock function with given fields: width, height
func (_m *Page) SetViewportSize(width int, height int) error {
	ret := _m.Called(width, height)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, int) error); ok {
		r0 = rf(width, height)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Tap provides a mock function with given fields: selector, options
func (_m *Page) Tap(selector string, options ...playwright.FrameTapOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameTapOptions) error); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TextContent provides a mock function with given fields: selector, options
func (_m *Page) TextContent(selector string, options ...playwright.FrameTextContentOptions) (string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameTextContentOptions) (string, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameTextContentOptions) string); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.FrameTextContentOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Title provides a mock function with given fields:
func (_m *Page) Title() (string, error) {
	ret := _m.Called()

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Touchscreen provides a mock function with given fields:
func (_m *Page) Touchscreen() playwright.Touchscreen {
	ret := _m.Called()

	var r0 playwright.Touchscreen
	if rf, ok := ret.Get(0).(func() playwright.Touchscreen); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Touchscreen)
		}
	}

	return r0
}

// Type provides a mock function with given fields: selector, text, options
func (_m *Page) Type(selector string, text string, options ...playwright.PageTypeOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector, text)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...playwright.PageTypeOptions) error); ok {
		r0 = rf(selector, text, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// URL provides a mock function with given fields:
func (_m *Page) URL() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Uncheck provides a mock function with given fields: selector, options
func (_m *Page) Uncheck(selector string, options ...playwright.FrameUncheckOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameUncheckOptions) error); ok {
		r0 = rf(selector, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Unroute provides a mock function with given fields: url, handler
func (_m *Page) Unroute(url interface{}, handler ...func(playwright.Route, playwright.Request)) error {
	_va := make([]interface{}, len(handler))
	for _i := range handler {
		_va[_i] = handler[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, url)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...func(playwright.Route, playwright.Request)) error); ok {
		r0 = rf(url, handler...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Video provides a mock function with given fields:
func (_m *Page) Video() playwright.Video {
	ret := _m.Called()

	var r0 playwright.Video
	if rf, ok := ret.Get(0).(func() playwright.Video); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Video)
		}
	}

	return r0
}

// ViewportSize provides a mock function with given fields:
func (_m *Page) ViewportSize() playwright.ViewportSize {
	ret := _m.Called()

	var r0 playwright.ViewportSize
	if rf, ok := ret.Get(0).(func() playwright.ViewportSize); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(playwright.ViewportSize)
	}

	return r0
}

// WaitForEvent provides a mock function with given fields: event, predicate
func (_m *Page) WaitForEvent(event string, predicate ...interface{}) interface{} {
	var _ca []interface{}
	_ca = append(_ca, event)
	_ca = append(_ca, predicate...)
	ret := _m.Called(_ca...)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) interface{}); ok {
		r0 = rf(event, predicate...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// WaitForFunction provides a mock function with given fields: expression, arg, options
func (_m *Page) WaitForFunction(expression string, arg interface{}, options ...playwright.FrameWaitForFunctionOptions) (playwright.JSHandle, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, expression, arg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 playwright.JSHandle
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, ...playwright.FrameWaitForFunctionOptions) (playwright.JSHandle, error)); ok {
		return rf(expression, arg, options...)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, ...playwright.FrameWaitForFunctionOptions) playwright.JSHandle); ok {
		r0 = rf(expression, arg, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.JSHandle)
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, ...playwright.FrameWaitForFunctionOptions) error); ok {
		r1 = rf(expression, arg, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WaitForLoadState provides a mock function with given fields: state
func (_m *Page) WaitForLoadState(state ...string) {
	_va := make([]interface{}, len(state))
	for _i := range state {
		_va[_i] = state[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// WaitForNavigation provides a mock function with given fields: options
func (_m *Page) WaitForNavigation(options ...playwright.PageWaitForNavigationOptions) (playwright.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 playwright.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(...playwright.PageWaitForNavigationOptions) (playwright.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...playwright.PageWaitForNavigationOptions) playwright.Response); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(...playwright.PageWaitForNavigationOptions) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WaitForRequest provides a mock function with given fields: url, options
func (_m *Page) WaitForRequest(url interface{}, options ...interface{}) playwright.Request {
	var _ca []interface{}
	_ca = append(_ca, url)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	var r0 playwright.Request
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) playwright.Request); ok {
		r0 = rf(url, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Request)
		}
	}

	return r0
}

// WaitForResponse provides a mock function with given fields: url, options
func (_m *Page) WaitForResponse(url interface{}, options ...interface{}) playwright.Response {
	var _ca []interface{}
	_ca = append(_ca, url)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	var r0 playwright.Response
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) playwright.Response); ok {
		r0 = rf(url, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.Response)
		}
	}

	return r0
}

// WaitForSelector provides a mock function with given fields: selector, options
func (_m *Page) WaitForSelector(selector string, options ...playwright.PageWaitForSelectorOptions) (playwright.ElementHandle, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, selector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 playwright.ElementHandle
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageWaitForSelectorOptions) (playwright.ElementHandle, error)); ok {
		return rf(selector, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...playwright.PageWaitForSelectorOptions) playwright.ElementHandle); ok {
		r0 = rf(selector, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(playwright.ElementHandle)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...playwright.PageWaitForSelectorOptions) error); ok {
		r1 = rf(selector, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WaitForTimeout provides a mock function with given fields: timeout
func (_m *Page) WaitForTimeout(timeout float64) {
	_m.Called(timeout)
}

// WaitForURL provides a mock function with given fields: url, options
func (_m *Page) WaitForURL(url string, options ...playwright.FrameWaitForURLOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, url)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...playwright.FrameWaitForURLOptions) error); ok {
		r0 = rf(url, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Workers provides a mock function with given fields:
func (_m *Page) Workers() []playwright.Worker {
	ret := _m.Called()

	var r0 []playwright.Worker
	if rf, ok := ret.Get(0).(func() []playwright.Worker); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]playwright.Worker)
		}
	}

	return r0
}

type mockConstructorTestingTNewPage interface {
	mock.TestingT
	Cleanup(func())
}

// NewPage creates a new instance of Page. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewPage(t mockConstructorTestingTNewPage) *Page {
	mock := &Page{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
